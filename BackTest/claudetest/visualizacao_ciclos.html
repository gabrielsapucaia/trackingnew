<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualização de Ciclos Operacionais</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.3rem;
            color: #4fc3f7;
        }

        .stats-bar {
            display: flex;
            gap: 25px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4fc3f7;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .map-container {
            flex: 1;
            background: #16213e;
            position: relative;
            min-width: 0;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 380px;
            background: #16213e;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            border-left: 1px solid #2a2a4a;
        }

        .sidebar-header {
            padding: 12px 15px;
            border-bottom: 1px solid #2a2a4a;
            flex-shrink: 0;
        }

        .sidebar-header h2 {
            font-size: 1rem;
            color: #4fc3f7;
            margin: 0;
        }

        .cycle-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .panel {
            background: #16213e;
            padding: 15px;
            flex-shrink: 0;
            border-top: 1px solid #2a2a4a;
        }

        .panel h2 {
            font-size: 0.9rem;
            color: #4fc3f7;
            margin-bottom: 10px;
        }

        .cycle-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid #4fc3f7;
        }

        .cycle-item:hover {
            background: #2a2a4a;
            transform: translateX(5px);
        }

        .cycle-item.selected {
            background: #2a2a4a;
            border-left-color: #ff9800;
        }

        .cycle-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .cycle-number {
            font-weight: bold;
            color: #4fc3f7;
        }

        .cycle-duration {
            color: #888;
            font-size: 0.85rem;
        }

        .cycle-bar {
            height: 20px;
            border-radius: 4px;
            display: flex;
            overflow: hidden;
            margin-top: 5px;
        }

        .bar-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .bar-carga { background: #4caf50; }
        .bar-desloc-carreg { background: #2196f3; }
        .bar-basculamento { background: #ff9800; }
        .bar-desloc-vazio { background: #9c27b0; }
        .bar-fora-ciclo { background: #666; opacity: 0.5; }
        .bar-parada-ociosa { background: #e91e63; opacity: 0.9; }

        .timeline-container {
            background: #0d1321;
            padding: 10px 15px;
            height: 120px;
            overflow: hidden;
            flex-shrink: 0;
            border-top: 1px solid #2a2a4a;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .timeline-header h2 {
            font-size: 1rem;
            color: #4fc3f7;
        }

        .legend {
            display: flex;
            gap: 20px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .timeline-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            height: calc(100% - 35px);
        }

        .timeline {
            height: 100%;
            min-width: 100%;
            position: relative;
        }

        .timeline-row {
            height: 30px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            position: relative;
        }

        .timeline-label {
            width: 60px;
            font-size: 0.75rem;
            color: #888;
            flex-shrink: 0;
        }

        .timeline-track {
            flex: 1;
            height: 20px;
            background: #1a1a2e;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .timeline-event {
            position: absolute;
            height: 100%;
            border-radius: 3px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .timeline-event:hover {
            opacity: 0.8;
        }

        .cycle-details {
            padding: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            margin-top: 10px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #2a2a4a;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: #888;
        }

        .detail-value {
            font-weight: bold;
        }

        .map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 0.8rem;
        }

        .map-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .map-legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }

        .play-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .play-btn {
            background: #4fc3f7;
            border: none;
            color: #1a1a2e;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .play-btn:hover {
            background: #81d4fa;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .speed-control label {
            font-size: 0.8rem;
            color: #888;
        }

        .speed-control select {
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #4fc3f7;
            padding: 5px;
            border-radius: 4px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #4fc3f7;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 20px;">
                <h1>Ciclos Operacionais - Caminhão Fora-de-Estrada</h1>
                <nav style="display: flex; gap: 5px;">
                    <a href="visualizacao_ciclos.html" style="padding: 6px 12px; border-radius: 6px; text-decoration: none; font-size: 0.8rem; color: #4fc3f7; border: 1px solid #4fc3f7; background: rgba(79,195,247,0.1);">Ciclos</a>
                    <a href="visualizacao_carregamentos.html" style="padding: 6px 12px; border-radius: 6px; text-decoration: none; font-size: 0.8rem; color: #888; border: 1px solid transparent;">Carregamentos</a>
                    <a href="editor_poligonos.html" style="padding: 6px 12px; border-radius: 6px; text-decoration: none; font-size: 0.8rem; color: #888; border: 1px solid transparent;">Editor</a>
                </nav>
            </div>
            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="totalCiclos">0</div>
                    <div class="stat-label">Ciclos</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="tempoMedio">0 min</div>
                    <div class="stat-label">Tempo Médio</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="cargaMedia">0 min</div>
                    <div class="stat-label">Carga Média</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="basculamentoMedio">0 min</div>
                    <div class="stat-label">Basculamento</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="foraCirclo" style="color: #666;">0 min</div>
                    <div class="stat-label">Fora de Ciclo</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
                <div class="map-legend">
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #4caf50;">C</div>
                        <span>Carregamento</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #ff9800;">B</div>
                        <span>Basculamento</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #2196f3;">-></div>
                        <span>Trajeto Carregado</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #9c27b0;">-></div>
                        <span>Trajeto Vazio</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #666; opacity: 0.5;">~</div>
                        <span>Fora de Ciclo</span>
                    </div>
                    <div class="map-legend-item">
                        <div class="map-legend-icon" style="background: #e91e63;">P</div>
                        <span>Parada Ociosa</span>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="sidebar-header">
                    <h2>Lista de Ciclos (42)</h2>
                </div>
                <div class="cycle-list" id="cycleList"></div>
                <div class="panel" id="detailsPanel" style="display: none;">
                    <h2>Detalhes do Ciclo</h2>
                    <div class="cycle-details" id="cycleDetails"></div>
                </div>
            </div>
        </div>

        <div class="timeline-container">
            <div class="timeline-header">
                <h2>Linha do Tempo</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color bar-carga"></div>
                        <span>Carregamento</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-desloc-carreg"></div>
                        <span>Desloc. Carregado</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-basculamento"></div>
                        <span>Basculamento</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-desloc-vazio"></div>
                        <span>Desloc. Vazio</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-fora-ciclo"></div>
                        <span>Fora de Ciclo</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-parada-ociosa"></div>
                        <span>Parada Ociosa</span>
                    </div>
                </div>
                <div class="play-controls">
                    <button class="play-btn" id="playBtn">Reproduzir</button>
                    <div class="speed-control">
                        <label>Velocidade:</label>
                        <select id="speedSelect">
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="5" selected>5x</option>
                            <option value="10">10x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="timeline-scroll">
                <div class="timeline" id="timeline"></div>
            </div>
        </div>
    </div>

    <script>
        // Dados dos ciclos (será carregado do CSV)
        let ciclos = [];
        let telemetria = [];
        let poligonos = [];
        let paradasOciosas = [];
        let map;
        let currentPath = null;
        let paradasOciosasMarkers = [];
        let animationId = null;
        let isPlaying = false;

        // Inicialização
        async function init() {
            await loadData();
            initMap();
            renderCycleList();
            renderTimeline();
            updateStats();
        }

        // Carregar dados
        async function loadData() {
            // Carregar ciclos
            const ciclosResponse = await fetch('extrato_ciclos.csv');
            const ciclosText = await ciclosResponse.text();
            ciclos = parseCSV(ciclosText);

            // Carregar telemetria
            const telemetriaResponse = await fetch('input.csv');
            const telemetriaText = await telemetriaResponse.text();
            telemetria = parseCSV(telemetriaText);

            // Carregar polígonos
            const poligonosResponse = await fetch('areas_carregamento.json');
            const poligonosData = await poligonosResponse.json();
            poligonos = poligonosData.features || [];

            // Carregar paradas ociosas
            try {
                const paradasResponse = await fetch('extrato_ciclos_paradas_ociosas.json');
                const paradasData = await paradasResponse.json();
                paradasOciosas = paradasData.paradas_ociosas || [];
                console.log(`Carregadas ${paradasOciosas.length} paradas ociosas`);
            } catch (e) {
                console.log('Arquivo de paradas ociosas não encontrado');
                paradasOciosas = [];
            }
        }

        function parseCSV(text) {
            // Remove \r characters (Windows line endings)
            text = text.replace(/\r/g, '');
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).filter(line => line.trim()).map(line => {
                const values = line.split(',');
                const obj = {};
                headers.forEach((h, i) => obj[h.trim()] = values[i] ? values[i].trim() : '');
                return obj;
            });
        }

        // Inicializar mapa
        function initMap() {
            // Bounds da ortofoto extraídos do GeoTIFF SIRGAS 2000 via gdalinfo
            // Arquivo: PAI-VO-20251218_sirgas.tif (EPSG:31983)
            // Corner Coordinates convertidas para graus decimais (WGS84/SIRGAS são compatíveis <1m)
            const imageBounds = [
                [-11.7094, -47.1711],  // SW (Lower Left)
                [-11.6840, -47.1484]   // NE (Upper Right)
            ];
            const center = [-11.6967, -47.1598];

            map = L.map('map', {
                minZoom: 14,
                maxZoom: 20
            }).setView(center, 16);

            // Camada de tiles OSM
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap'
            });

            // Camada ortofoto SIRGAS 2000 com 60% de opacidade
            const orthoLayer = L.imageOverlay('ortho_sirgas_q5.webp', imageBounds, {
                opacity: 0.6
            });

            // Adicionar OSM como base, ortofoto como overlay
            osmLayer.addTo(map);
            orthoLayer.addTo(map);

            // Controle de camadas
            const overlays = {
                "Ortofoto (60%)": orthoLayer
            };
            L.control.layers(null, overlays).addTo(map);

            // Desenhar polígonos
            poligonos.forEach(p => {
                const coords = p.geometry.coordinates[0].map(c => [c[1], c[0]]);
                L.polygon(coords, {
                    color: '#2ecc71',
                    fillColor: '#2ecc71',
                    fillOpacity: 0.3,
                    weight: 2
                }).addTo(map).bindPopup(`<b>${p.properties.name}</b>`);
            });

        }

        // Mostrar paradas ociosas de um ciclo específico no mapa
        function showParadasOciosasDoCiclo(paradas) {
            // Limpar marcadores anteriores
            paradasOciosasMarkers.forEach(m => map.removeLayer(m));
            paradasOciosasMarkers = [];

            paradas.forEach(p => {
                const lat = parseFloat(p.latitude);
                const lon = parseFloat(p.longitude);
                if (isNaN(lat) || isNaN(lon)) return;

                const duracao = formatTime(p.duracao_sec);
                const inicio = new Date(p.inicio).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

                // Determinar tipo de parada
                let tipo = 'Aguardando';
                if (p.duracao_sec > 1800) {
                    tipo = 'Refeição/Pausa Longa';
                } else if (p.duracao_sec > 600) {
                    tipo = 'Pausa';
                } else if (p.fase === 'entre_carga_basc') {
                    tipo = 'Fila (antes do basculamento)';
                } else if (p.fase === 'apos_basc') {
                    tipo = 'Aguardando (após basculamento)';
                }

                const marker = L.circleMarker([lat, lon], {
                    radius: 6,
                    color: '#e91e63',
                    fillColor: '#e91e63',
                    fillOpacity: 0.8,
                    weight: 2
                }).addTo(map).bindPopup(
                    `<b>Parada Ociosa</b><br>` +
                    `Ciclo: ${p.ciclo_num}<br>` +
                    `Tipo: ${tipo}<br>` +
                    `Início: ${inicio}<br>` +
                    `Duração: ${duracao}`
                );

                paradasOciosasMarkers.push(marker);
            });
        }

        // Renderizar lista de ciclos
        function renderCycleList() {
            const list = document.getElementById('cycleList');
            list.innerHTML = '';

            ciclos.forEach((ciclo, index) => {
                const total = parseInt(ciclo.ciclo_total_sec) || 0;
                const carga = parseInt(ciclo.carga_duracao_sec) || 0;
                const deslocCarreg = parseInt(ciclo.desloc_carregado_sec) || 0;
                const basculamento = parseInt(ciclo.basculamento_duracao_sec) || 0;
                const deslocVazio = parseInt(ciclo.desloc_vazio_sec) || 0;

                // Calcular tempo de parada ociosa deste ciclo
                const cicloNum = parseInt(ciclo.ciclo);
                const paradaOciosa = paradasOciosas
                    .filter(p => p.ciclo_num === cicloNum)
                    .reduce((sum, p) => sum + p.duracao_sec, 0);

                const item = document.createElement('div');
                item.className = 'cycle-item';

                // Calcular porcentagens (parada ociosa vem do desloc vazio)
                const deslocVazioReal = Math.max(0, deslocVazio - paradaOciosa);

                item.innerHTML = `
                    <div class="cycle-header">
                        <span class="cycle-number">Ciclo ${ciclo.ciclo}</span>
                        <span class="cycle-duration">${formatTime(total)}</span>
                    </div>
                    <div style="font-size: 0.8rem; color: #888; margin-bottom: 5px;">
                        ${ciclo.carga_area} → ${ciclo.basculamento_area}
                    </div>
                    <div class="cycle-bar">
                        <div class="bar-segment bar-carga" style="width: ${(carga/total*100).toFixed(1)}%"></div>
                        <div class="bar-segment bar-desloc-carreg" style="width: ${(deslocCarreg/total*100).toFixed(1)}%"></div>
                        <div class="bar-segment bar-basculamento" style="width: ${(basculamento/total*100).toFixed(1)}%"></div>
                        <div class="bar-segment bar-desloc-vazio" style="width: ${(deslocVazioReal/total*100).toFixed(1)}%"></div>
                        ${paradaOciosa > 0 ? `<div class="bar-segment bar-parada-ociosa" style="width: ${(paradaOciosa/total*100).toFixed(1)}%"></div>` : ''}
                    </div>
                `;

                item.addEventListener('click', () => selectCycle(index));
                list.appendChild(item);
            });
        }

        // Selecionar ciclo
        function selectCycle(index) {
            // Remover seleção anterior
            document.querySelectorAll('.cycle-item').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.cycle-item')[index].classList.add('selected');

            const ciclo = ciclos[index];
            showCycleDetails(ciclo);
            showCycleOnMap(ciclo);
        }

        // Mostrar detalhes do ciclo
        function showCycleDetails(ciclo) {
            const panel = document.getElementById('detailsPanel');
            const details = document.getElementById('cycleDetails');

            panel.style.display = 'block';

            details.innerHTML = `
                <div class="detail-row">
                    <span class="detail-label">Início</span>
                    <span class="detail-value">${formatDateTime(ciclo.carga_inicio)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Carregamento</span>
                    <span class="detail-value" style="color: #4caf50">${formatTime(ciclo.carga_duracao_sec)} em ${ciclo.carga_area}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Desloc. Carregado</span>
                    <span class="detail-value" style="color: #2196f3">${formatTime(ciclo.desloc_carregado_sec)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Basculamento</span>
                    <span class="detail-value" style="color: #ff9800">${formatTime(ciclo.basculamento_duracao_sec)} em ${ciclo.basculamento_area}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Desloc. Vazio</span>
                    <span class="detail-value" style="color: #9c27b0">${formatTime(ciclo.desloc_vazio_sec)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Total do Ciclo</span>
                    <span class="detail-value" style="color: #4fc3f7">${formatTime(ciclo.ciclo_total_sec)}</span>
                </div>
            `;
        }

        // Mostrar ciclo no mapa
        function showCycleOnMap(ciclo) {
            // Limpar trajeto anterior
            if (currentPath) {
                currentPath.forEach(p => map.removeLayer(p));
            }
            currentPath = [];

            const cargaInicio = new Date(ciclo.carga_inicio);
            const cargaFim = new Date(ciclo.carga_fim);
            const bascInicio = ciclo.basculamento_inicio ? new Date(ciclo.basculamento_inicio) : null;
            const bascFim = ciclo.basculamento_fim ? new Date(ciclo.basculamento_fim) : null;

            // Encontrar próximo ciclo para determinar fim
            const cicloNum = parseInt(ciclo.ciclo);
            const proxCiclo = ciclos.find(c => parseInt(c.ciclo) === cicloNum + 1);
            const fimCiclo = proxCiclo ? new Date(proxCiclo.carga_inicio) : new Date(ciclo.basculamento_fim);

            // Filtrar telemetria do ciclo
            const dadosCiclo = telemetria.filter(t => {
                const time = new Date(t.time);
                return time >= cargaInicio && time <= fimCiclo;
            });

            if (dadosCiclo.length === 0) return;

            // Separar em segmentos
            const segmentos = {
                carga: [],
                deslocCarreg: [],
                basculamento: [],
                deslocVazio: []
            };

            dadosCiclo.forEach(d => {
                const time = new Date(d.time);
                const lat = parseFloat(d.latitude);
                const lon = parseFloat(d.longitude);

                if (isNaN(lat) || isNaN(lon)) return;

                // Coordenadas GPS (WGS84) são compatíveis com SIRGAS 2000 (<1m diferença)
                // Não é necessário transformação de datum

                if (time >= cargaInicio && time <= cargaFim) {
                    segmentos.carga.push([lat, lon]);
                } else if (bascInicio && time > cargaFim && time < bascInicio) {
                    segmentos.deslocCarreg.push([lat, lon]);
                } else if (bascInicio && bascFim && time >= bascInicio && time <= bascFim) {
                    segmentos.basculamento.push([lat, lon]);
                } else if (bascFim && time > bascFim) {
                    segmentos.deslocVazio.push([lat, lon]);
                }
            });

            // Desenhar trajetos
            if (segmentos.deslocCarreg.length > 1) {
                const path = L.polyline(segmentos.deslocCarreg, {
                    color: '#2196f3',
                    weight: 4,
                    opacity: 0.8
                }).addTo(map);
                currentPath.push(path);
            }

            if (segmentos.deslocVazio.length > 1) {
                const path = L.polyline(segmentos.deslocVazio, {
                    color: '#9c27b0',
                    weight: 4,
                    opacity: 0.8,
                    dashArray: '10, 10'
                }).addTo(map);
                currentPath.push(path);
            }

            // Marcadores
            if (segmentos.carga.length > 0) {
                const marker = L.circleMarker(segmentos.carga[0], {
                    radius: 10,
                    color: '#4caf50',
                    fillColor: '#4caf50',
                    fillOpacity: 1
                }).addTo(map).bindPopup(`<b>Carregamento</b><br>${ciclo.carga_area}<br>${formatTime(ciclo.carga_duracao_sec)}`);
                currentPath.push(marker);
            }

            if (segmentos.basculamento.length > 0) {
                const marker = L.circleMarker(segmentos.basculamento[0], {
                    radius: 10,
                    color: '#ff9800',
                    fillColor: '#ff9800',
                    fillOpacity: 1
                }).addTo(map).bindPopup(`<b>Basculamento</b><br>${ciclo.basculamento_area}<br>${formatTime(ciclo.basculamento_duracao_sec)}`);
                currentPath.push(marker);
            }

            // Ajustar zoom para mostrar todo o trajeto
            const allPoints = [...segmentos.carga, ...segmentos.deslocCarreg, ...segmentos.basculamento, ...segmentos.deslocVazio];
            if (allPoints.length > 0) {
                map.fitBounds(allPoints, { padding: [50, 50] });
            }

            // Mostrar apenas paradas ociosas deste ciclo
            const paradasDoCiclo = paradasOciosas.filter(p => p.ciclo_num === cicloNum);
            showParadasOciosasDoCiclo(paradasDoCiclo);
        }

        // Renderizar timeline
        function renderTimeline() {
            const timeline = document.getElementById('timeline');
            timeline.innerHTML = '';

            if (ciclos.length === 0 || telemetria.length === 0) return;

            // Encontrar início e fim absolutos DA TELEMETRIA (não dos ciclos)
            const inicioTelemetria = new Date(telemetria[0].time);
            const fimTelemetria = new Date(telemetria[telemetria.length - 1].time);

            const inicio = inicioTelemetria;
            const fimTotal = fimTelemetria;

            const duracao = fimTotal - inicio;
            const pixelsPerHour = 150;
            const totalWidth = (duracao / 3600000) * pixelsPerHour;

            timeline.style.width = `${Math.max(totalWidth, 800)}px`;

            // Criar track para cada hora
            const horas = Math.ceil(duracao / 3600000);

            // Criar linha de tempo com marcadores de hora
            const timeAxis = document.createElement('div');
            timeAxis.className = 'timeline-row';
            timeAxis.innerHTML = `<div class="timeline-label">Hora</div><div class="timeline-track" id="timeTrack"></div>`;
            timeline.appendChild(timeAxis);

            const timeTrack = document.getElementById('timeTrack');
            for (let h = 0; h <= horas; h++) {
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    left: ${(h / horas) * 100}%;
                    top: 0;
                    height: 100%;
                    border-left: 1px solid #4fc3f7;
                    font-size: 0.7rem;
                    color: #4fc3f7;
                    padding-left: 3px;
                `;
                const time = new Date(inicio.getTime() + h * 3600000);
                marker.textContent = time.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                timeTrack.appendChild(marker);
            }

            // Criar linha para eventos
            const eventRow = document.createElement('div');
            eventRow.className = 'timeline-row';
            eventRow.innerHTML = `<div class="timeline-label">Eventos</div><div class="timeline-track" id="eventTrack"></div>`;
            timeline.appendChild(eventRow);

            const eventTrack = document.getElementById('eventTrack');

            // Adicionar período ANTES do primeiro ciclo (fora de ciclo)
            const primeiroCicloInicio = new Date(ciclos[0].carga_inicio);
            if (primeiroCicloInicio > inicio) {
                addTimelineEventForaCiclo(eventTrack, inicio, duracao, inicio, primeiroCicloInicio - inicio, 'Antes do 1º ciclo');
            }

            ciclos.forEach((ciclo, index) => {
                const cargaInicio = new Date(ciclo.carga_inicio);
                const cargaDuracao = parseInt(ciclo.carga_duracao_sec) * 1000;
                const deslocCarreg = parseInt(ciclo.desloc_carregado_sec) * 1000;
                const bascDuracao = parseInt(ciclo.basculamento_duracao_sec) * 1000;
                const deslocVazio = parseInt(ciclo.desloc_vazio_sec) * 1000;

                // Carregamento
                addTimelineEvent(eventTrack, ciclo, inicio, duracao, cargaInicio, cargaDuracao, 'bar-carga', index);

                // Deslocamento carregado
                const deslocCarregInicio = new Date(cargaInicio.getTime() + cargaDuracao);
                addTimelineEvent(eventTrack, ciclo, inicio, duracao, deslocCarregInicio, deslocCarreg, 'bar-desloc-carreg', index);

                // Basculamento
                if (ciclo.basculamento_inicio) {
                    const bascInicio = new Date(ciclo.basculamento_inicio);
                    addTimelineEvent(eventTrack, ciclo, inicio, duracao, bascInicio, bascDuracao, 'bar-basculamento', index);

                    // Deslocamento vazio
                    const deslocVazioInicio = new Date(bascInicio.getTime() + bascDuracao);
                    addTimelineEvent(eventTrack, ciclo, inicio, duracao, deslocVazioInicio, deslocVazio, 'bar-desloc-vazio', index);
                }
            });

            // Adicionar paradas ociosas à timeline
            paradasOciosas.forEach(p => {
                const paradaInicio = new Date(p.inicio);
                const paradaDuracao = p.duracao_sec * 1000;
                // Encontrar o índice do ciclo para o click handler
                const cicloIndex = ciclos.findIndex(c => parseInt(c.ciclo) === p.ciclo_num);
                addTimelineEventParadaOciosa(eventTrack, inicio, duracao, paradaInicio, paradaDuracao, p, cicloIndex);
            });

            // Criar linha para identificação dos ciclos
            const cycleRow = document.createElement('div');
            cycleRow.className = 'timeline-row';
            cycleRow.innerHTML = `<div class="timeline-label">Ciclos</div><div class="timeline-track" id="cycleTrack"></div>`;
            timeline.appendChild(cycleRow);

            const cycleTrack = document.getElementById('cycleTrack');

            // Adicionar marcadores de ciclos
            ciclos.forEach((ciclo, index) => {
                const cargaInicio = new Date(ciclo.carga_inicio);
                const cicloTotal = parseInt(ciclo.ciclo_total_sec) * 1000;

                const left = ((cargaInicio - inicio) / duracao) * 100;
                const width = (cicloTotal / duracao) * 100;

                const cycleMarker = document.createElement('div');
                cycleMarker.className = 'timeline-cycle-marker';
                cycleMarker.style.cssText = `
                    position: absolute;
                    left: ${left}%;
                    width: ${Math.max(width, 0.5)}%;
                    height: 100%;
                    background: rgba(79, 195, 247, 0.2);
                    border: 1px solid #4fc3f7;
                    border-radius: 3px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.65rem;
                    color: #4fc3f7;
                    cursor: pointer;
                    transition: background 0.2s;
                `;
                cycleMarker.textContent = ciclo.ciclo;
                cycleMarker.title = `Ciclo ${ciclo.ciclo} - ${formatTime(ciclo.ciclo_total_sec)}`;
                cycleMarker.addEventListener('click', () => selectCycle(index));
                cycleMarker.addEventListener('mouseenter', () => {
                    cycleMarker.style.background = 'rgba(79, 195, 247, 0.4)';
                });
                cycleMarker.addEventListener('mouseleave', () => {
                    cycleMarker.style.background = 'rgba(79, 195, 247, 0.2)';
                });
                cycleTrack.appendChild(cycleMarker);
            });

            // Adicionar período APÓS o último ciclo (fora de ciclo)
            const ultimoCiclo = ciclos[ciclos.length - 1];
            const ultimoBascFim = ultimoCiclo.basculamento_fim ? new Date(ultimoCiclo.basculamento_fim) : new Date(ultimoCiclo.carga_fim);
            const fimUltimoCiclo = new Date(ultimoBascFim.getTime() + parseInt(ultimoCiclo.desloc_vazio_sec || 0) * 1000);
            if (fimUltimoCiclo < fimTotal) {
                addTimelineEventForaCiclo(eventTrack, inicio, duracao, fimUltimoCiclo, fimTotal - fimUltimoCiclo, 'Após último ciclo');
            }
        }

        function addTimelineEventForaCiclo(track, inicio, duracao, eventStart, eventDuration, titulo) {
            const left = ((eventStart - inicio) / duracao) * 100;
            const width = (eventDuration / duracao) * 100;

            const event = document.createElement('div');
            event.className = 'timeline-event bar-fora-ciclo';
            event.style.left = `${left}%`;
            event.style.width = `${Math.max(width, 0.2)}%`;
            event.title = `${titulo} (${formatTime(eventDuration / 1000)})`;
            track.appendChild(event);
        }

        function addTimelineEvent(track, ciclo, inicio, duracao, eventStart, eventDuration, className, index) {
            const left = ((eventStart - inicio) / duracao) * 100;
            const width = (eventDuration / duracao) * 100;

            const event = document.createElement('div');
            event.className = `timeline-event ${className}`;
            event.style.left = `${left}%`;
            event.style.width = `${Math.max(width, 0.2)}%`;
            event.title = `Ciclo ${ciclo.ciclo}`;
            event.addEventListener('click', () => selectCycle(index));
            track.appendChild(event);
        }

        function addTimelineEventParadaOciosa(track, inicio, duracao, eventStart, eventDuration, parada, cicloIndex) {
            const left = ((eventStart - inicio) / duracao) * 100;
            const width = (eventDuration / duracao) * 100;

            // Determinar tipo de parada
            let tipo = 'Aguardando';
            if (parada.duracao_sec > 1800) {
                tipo = 'Refeição/Pausa Longa';
            } else if (parada.duracao_sec > 600) {
                tipo = 'Pausa';
            } else if (parada.fase === 'entre_carga_basc') {
                tipo = 'Fila';
            } else if (parada.fase === 'apos_basc') {
                tipo = 'Aguardando';
            }

            const event = document.createElement('div');
            event.className = 'timeline-event bar-parada-ociosa';
            event.style.left = `${left}%`;
            event.style.width = `${Math.max(width, 0.3)}%`;
            event.style.zIndex = '10'; // Ficar acima de outros eventos
            event.style.cursor = 'pointer';
            event.title = `Parada Ociosa - ${tipo}\nCiclo ${parada.ciclo_num}\nDuração: ${formatTime(parada.duracao_sec)}\n(Clique para selecionar o ciclo)`;
            if (cicloIndex >= 0) {
                event.addEventListener('click', () => selectCycle(cicloIndex));
            }
            track.appendChild(event);
        }

        // Atualizar estatísticas
        function updateStats() {
            document.getElementById('totalCiclos').textContent = ciclos.length;

            if (ciclos.length === 0) return;

            const tempoTotal = ciclos.reduce((sum, c) => sum + (parseInt(c.ciclo_total_sec) || 0), 0);
            const cargaTotal = ciclos.reduce((sum, c) => sum + (parseInt(c.carga_duracao_sec) || 0), 0);
            const bascTotal = ciclos.reduce((sum, c) => sum + (parseInt(c.basculamento_duracao_sec) || 0), 0);

            document.getElementById('tempoMedio').textContent = formatTime(tempoTotal / ciclos.length);
            document.getElementById('cargaMedia').textContent = formatTime(cargaTotal / ciclos.length);
            document.getElementById('basculamentoMedio').textContent = formatTime(bascTotal / ciclos.length);

            // Calcular tempo fora de ciclo
            if (telemetria.length > 0) {
                const inicioTelemetria = new Date(telemetria[0].time);
                const fimTelemetria = new Date(telemetria[telemetria.length - 1].time);
                const duracaoTotalTelemetria = (fimTelemetria - inicioTelemetria) / 1000; // em segundos

                const tempoForaCiclo = duracaoTotalTelemetria - tempoTotal;
                document.getElementById('foraCirclo').textContent = formatTime(tempoForaCiclo);
            }
        }

        // Formatadores
        function formatTime(seconds) {
            const s = parseInt(seconds) || 0;
            if (s < 60) return `${s}s`;
            if (s < 3600) return `${Math.floor(s/60)}m ${s%60}s`;
            return `${Math.floor(s/3600)}h ${Math.floor((s%3600)/60)}m`;
        }

        function formatDateTime(isoString) {
            if (!isoString) return '-';
            const d = new Date(isoString);
            return d.toLocaleString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Reprodução animada
        document.getElementById('playBtn').addEventListener('click', togglePlay);

        function togglePlay() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isPlaying = true;
            document.getElementById('playBtn').textContent = 'Pausar';

            let currentIndex = 0;
            const speed = parseInt(document.getElementById('speedSelect').value);

            function animate() {
                if (!isPlaying || currentIndex >= ciclos.length) {
                    stopAnimation();
                    return;
                }

                selectCycle(currentIndex);

                // Scroll para o item atual
                const items = document.querySelectorAll('.cycle-item');
                items[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });

                currentIndex++;
                animationId = setTimeout(animate, 2000 / speed);
            }

            animate();
        }

        function stopAnimation() {
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'Reproduzir';
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        }

        // Iniciar
        init();
    </script>
</body>
</html>
